import 'package:meta/meta.dart';

/// Base class for all events in the system.
///
/// Events are domain messages broadcasted via the [SignalBus].
/// All events have a [correlationId] linking them to the originating job.
///
/// ## Creating Domain Events
///
/// ```dart
/// class UsersLoadedEvent extends BaseEvent {
///   final List<User> users;
///   final DataSource source;
///
///   UsersLoadedEvent({
///     required String correlationId,
///     required this.users,
///     this.source = DataSource.fresh,
///   }) : super(correlationId);
/// }
/// ```
@immutable
abstract class BaseEvent {
  /// ID of the Job that generated this event (Correlation ID).
  final String correlationId;

  /// Timestamp when the event was emitted.
  final DateTime timestamp;

  BaseEvent(this.correlationId) : timestamp = DateTime.now();

  @override
  String toString() => '$runtimeType(id: $correlationId)';
}

// ============================================================================
// LEGACY FRAMEWORK EVENTS
// ============================================================================
//
// The following events are deprecated and will be removed in v2.0.0.
// Use EventJob with custom domain events instead.
//
// Migration: Instead of listening to JobSuccessEvent, define your own
// domain event and use EventJob<TResult, TEvent> to emit it.
// ============================================================================

// ============ Result Events (Legacy) ============

/// Emitted when a Job completes successfully.
///
/// @Deprecated: Use [EventJob] with custom domain events instead.
/// This event is only emitted for legacy [BaseJob] jobs, not [EventJob].
@Deprecated('Use EventJob with custom domain events. Will be removed in v2.0.0')
class JobSuccessEvent<T> extends BaseEvent {
  final T data;
  final bool isOptimistic;

  /// The type name of the job that generated this event.
  /// Useful for filtering in passive event handlers.
  final String? jobType;

  JobSuccessEvent(
    super.correlationId,
    this.data, {
    this.isOptimistic = false,
    this.jobType,
  });

  /// Check if this event was generated by a specific job type.
  ///
  /// Example:
  /// ```dart
  /// if (event.isFromJobType<FetchUserJob>()) {
  ///   // Handle FetchUserJob success
  /// }
  /// ```
  bool isFromJobType<J>() => jobType == J.toString();

  /// Safe cast helper.
  /// Returns [data] as [R] if type matches, otherwise returns null.
  /// Avoids runtime exceptions when casting generic data.
  R? dataAs<R>() {
    if (data is R) return data as R;
    return null;
  }

  @override
  String toString() =>
      'JobSuccessEvent(id: $correlationId, type: $jobType, data: $data, optimistic: $isOptimistic)';
}

/// Emitted when a Job fails.
///
/// @Deprecated: Use [JobHandle.future] to catch errors instead.
/// For global error logging, use [OrchestratorObserver.onJobError].
@Deprecated(
    'Use JobHandle.future for error handling. Will be removed in v2.0.0')
class JobFailureEvent extends BaseEvent {
  final Object error;
  final StackTrace? stackTrace;
  final bool wasRetried;

  /// The type name of the job that generated this event.
  /// Useful for filtering in passive event handlers.
  final String? jobType;

  JobFailureEvent(
    super.correlationId,
    this.error, {
    this.stackTrace,
    this.wasRetried = false,
    this.jobType,
  });

  /// Check if this event was generated by a specific job type.
  bool isFromJobType<J>() => jobType == J.toString();

  @override
  String toString() =>
      'JobFailureEvent(id: $correlationId, type: $jobType, error: $error)';
}

/// Emitted when a Job is cancelled.
///
/// @Deprecated: Use [CancellationToken] and [JobHandle.future] instead.
@Deprecated('Use CancellationToken with JobHandle. Will be removed in v2.0.0')
class JobCancelledEvent extends BaseEvent {
  final String? reason;

  /// The type name of the job that generated this event.
  final String? jobType;

  JobCancelledEvent(super.correlationId, {this.reason, this.jobType});

  /// Check if this event was generated by a specific job type.
  bool isFromJobType<J>() => jobType == J.toString();

  @override
  String toString() =>
      'JobCancelledEvent(id: $correlationId, type: $jobType, reason: $reason)';
}

/// Emitted when a Job times out.
///
/// @Deprecated: Use [JobHandle.future] timeout handling instead.
@Deprecated('Use JobHandle.future for timeout handling. Will be removed in v2.0.0')
class JobTimeoutEvent extends BaseEvent {
  final Duration timeout;

  /// The type name of the job that generated this event.
  final String? jobType;

  JobTimeoutEvent(super.correlationId, this.timeout, {this.jobType});

  /// Check if this event was generated by a specific job type.
  bool isFromJobType<J>() => jobType == J.toString();

  @override
  String toString() =>
      'JobTimeoutEvent(id: $correlationId, type: $jobType, timeout: ${timeout.inSeconds}s)';
}

/// Emitted when data is found in cache (Unified Data Flow).
///
/// @Deprecated: Use [EventJob] which emits domain events for both cache and fresh data.
/// The event's [DataSource] field indicates the data origin.
@Deprecated('Use EventJob with DataSource in your domain event. Will be removed in v2.0.0')
class JobCacheHitEvent<T> extends BaseEvent {
  final T data;

  /// The type name of the job that generated this event.
  final String? jobType;

  JobCacheHitEvent(super.correlationId, this.data, {this.jobType});

  /// Check if this event was generated by a specific job type.
  bool isFromJobType<J>() => jobType == J.toString();

  @override
  String toString() =>
      'JobCacheHitEvent(id: $correlationId, type: $jobType, data: $data)';
}

/// Emitted when placeholder data is available (Unified Data Flow).
///
/// @Deprecated: Use [DataStrategy.placeholder] with legacy jobs,
/// or handle loading states via [JobHandle] for EventJob.
@Deprecated('Use DataStrategy.placeholder or JobHandle. Will be removed in v2.0.0')
class JobPlaceholderEvent<T> extends BaseEvent {
  final T data;

  /// The type name of the job that generated this event.
  final String? jobType;

  JobPlaceholderEvent(super.correlationId, this.data, {this.jobType});

  /// Check if this event was generated by a specific job type.
  bool isFromJobType<J>() => jobType == J.toString();

  @override
  String toString() =>
      'JobPlaceholderEvent(id: $correlationId, type: $jobType, data: $data)';
}

// ============ Progress Events (Legacy) ============

/// Emitted to report progress of a long-running job.
///
/// @Deprecated: Use [JobHandle.progress] stream instead.
@Deprecated('Use JobHandle.progress stream. Will be removed in v2.0.0')
class JobProgressEvent extends BaseEvent {
  /// Progress value (0.0 to 1.0).
  ///
  /// Values outside this range will be clamped automatically.
  final double progress;

  /// Optional message.
  final String? message;

  /// Optional: Current step / Total steps.
  final int? currentStep;
  final int? totalSteps;

  JobProgressEvent(
    super.correlationId, {
    required double progress,
    this.message,
    this.currentStep,
    this.totalSteps,
  }) : progress = progress.clamp(0.0, 1.0) {
    assert(
      currentStep == null || totalSteps == null || currentStep! <= totalSteps!,
      'currentStep ($currentStep) cannot be greater than totalSteps ($totalSteps)',
    );
  }

  @override
  String toString() =>
      'JobProgressEvent(id: $correlationId, progress: ${(progress * 100).toStringAsFixed(1)}%)';
}

// ============ Lifecycle Events (Legacy) ============

/// Emitted when a Job starts executing.
///
/// @Deprecated: Use [OrchestratorObserver.onJobStart] for logging.
@Deprecated('Use OrchestratorObserver.onJobStart. Will be removed in v2.0.0')
class JobStartedEvent extends BaseEvent {
  final String jobType;
  JobStartedEvent(super.correlationId, {required this.jobType});

  @override
  String toString() => 'JobStartedEvent(id: $correlationId, type: $jobType)';
}

/// Emitted when a Job is retrying after failure.
///
/// @Deprecated: Retry events are internal implementation details.
/// Use [OrchestratorObserver] for retry logging if needed.
@Deprecated('Use OrchestratorObserver for retry logging. Will be removed in v2.0.0')
class JobRetryingEvent extends BaseEvent {
  final int attempt;
  final int maxRetries;
  final Object lastError;
  final Duration delayBeforeRetry;

  JobRetryingEvent(
    super.correlationId, {
    required this.attempt,
    required this.maxRetries,
    required this.lastError,
    required this.delayBeforeRetry,
  });

  @override
  String toString() =>
      'JobRetryingEvent(id: $correlationId, attempt: $attempt/$maxRetries)';
}

// ============ Network Sync Events ============

/// Emitted when a network-queued job fails during background sync.
///
/// Orchestrators can listen to this event to:
/// - Rollback optimistic UI updates
/// - Show error notifications to user
/// - Log sync failures
///
/// Note: This event is kept as it's useful for offline-first apps.
/// Consider defining your own domain event for more specific handling.
class NetworkSyncFailureEvent extends BaseEvent {
  /// The error that caused the sync failure.
  final Object error;

  /// Stack trace of the error.
  final StackTrace? stackTrace;

  /// Number of times this job has been retried.
  final int retryCount;

  /// If true, this job has exceeded max retries and will be abandoned.
  /// Orchestrators should treat this as a permanent failure.
  final bool isPoisoned;

  NetworkSyncFailureEvent(
    super.correlationId, {
    required this.error,
    this.stackTrace,
    required this.retryCount,
    required this.isPoisoned,
  });

  @override
  String toString() =>
      'NetworkSyncFailureEvent(id: $correlationId, retry: $retryCount, poisoned: $isPoisoned)';
}

// ============ DevTools Events ============

/// Emitted to update the Executor Registry in DevTools.
class ExecutorRegistryEvent extends BaseEvent {
  /// Map of Job Type Name -> Executor Type Name
  final Map<String, String> registry;

  ExecutorRegistryEvent(this.registry) : super('system_registry_event');

  @override
  String toString() => 'ExecutorRegistryEvent(count: ${registry.length})';
}
